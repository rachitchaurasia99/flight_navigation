class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}}function t(t){const e={addNode:c,removeNode:function(n){return Object.keys(o).forEach(function(t){o[t].forEach(function(e){e===n&&d(t,e)})}),delete o[n],e},nodes:i,adjacent:u,addEdge:a,removeEdge:d,hasEdge:l,setEdgeWeight:s,getEdgeWeight:h,indegree:function(n){let t=0;function e(e){e===n&&t++}return Object.keys(o).forEach(function(n){o[n].forEach(e)}),t},outdegree:function(n){return n in o?o[n].length:0},depthFirstSearch:E,hasCycle:function(){try{return E(void 0,!0,!0),!1}catch(t){if(t instanceof n)return!0;throw t}},lowestCommonAncestors:function(n,t){const e=[],o=[];return function n(r,c){return!!r[c]||(r[c]=!0,e.push(c),c==t?(o.push(c),!1):u(c).every(t=>n(r,t)))}({},n)&&function n(t,r){t[r]||(t[r]=!0,e.indexOf(r)>=0?o.push(r):0==o.length&&u(r).forEach(e=>{n(t,e)}))}({},t),o},topologicalSort:function(n,t=!0){return E(n,t,!0).reverse()},shortestPath:g,shortestPaths:function(n,t){let e=g(n,t);const o=[e],r=[],c=e.weight;for(;c;){const i=e[0],u=e[1];l(i,u)&&(r.push({u:i,v:u,weight:h(i,u)}),d(i,u)),l(u,i)&&(r.push({u,v:i,weight:h(u,i)}),d(u,i));try{if(e=g(n,t),!e.weight||c<e.weight)break;o.push(e)}catch(n){break}}for(const{u:n,v:t,weight:e}of r)a(n,t,e);return o},serialize:function(){const n={nodes:i().map(function(n){return{id:n}}),links:[]};return n.nodes.forEach(function(t){const e=t.id;u(e).forEach(function(t){n.links.push({source:e,target:t,weight:h(e,t)})})}),n},deserialize:p},o={},r={};function c(n){return o[n]=u(n),e}function i(){const n={};return Object.keys(o).forEach(function(t){n[t]=!0,o[t].forEach(function(t){n[t]=!0})}),Object.keys(n)}function u(n){return o[n]||[]}function f(n,t){return n+"|"+t}function s(n,t,o){return r[f(n,t)]=o,e}function h(n,t){const e=r[f(n,t)];return void 0===e?1:e}function a(n,t,o){return c(n),c(t),u(n).push(t),void 0!==o&&s(n,t,o),e}function d(n,t){return o[n]&&(o[n]=u(n).filter(function(n){return n!==t})),e}function l(n,t){return u(n).includes(t)}function E(t,e=!0,o=!1){t||(t=i()),"boolean"!=typeof e&&(e=!0);const r={},c={},f=[];function s(t){if(c[t]&&o)throw new n("Cycle found");r[t]||(r[t]=!0,c[t]=!0,u(t).forEach(s),c[t]=!1,f.push(t))}return e?t.forEach(s):(t.forEach(function(n){r[n]=!0}),t.forEach(function(n){u(n).forEach(s)})),f}function g(n,t){const e={},o={};let r={};function c(){let n,t=Infinity;return Object.keys(r).forEach(function(o){e[o]<t&&(t=e[o],n=o)}),void 0===n?(r={},null):(delete r[n],n)}function f(n,t){const r=h(n,t);e[t]>e[n]+r&&(e[t]=e[n]+r,o[t]=n)}return function(){for(function(){if(i().forEach(function(n){e[n]=Infinity}),Infinity!==e[n])throw new Error("Source node is not in the graph");if(Infinity!==e[t])throw new Error("Destination node is not in the graph");e[n]=0}(),i().forEach(function(n){r[n]=!0});0!==Object.keys(r).length;){const n=c();if(null===n)return;u(n).forEach(function(t){f(n,t)})}}(),function(){const e=[];let r=0,c=t;for(;o[c];)e.push(c),r+=h(o[c],c),c=o[c];if(c!==n)throw new Error("No path found");return e.push(c),e.reverse(),e.weight=r,e}()}function p(n){return n.nodes.forEach(function(n){c(n.id)}),n.links.forEach(function(n){a(n.source,n.target,n.weight)}),e}return t&&p(t),e}export{n as CycleError,t as Graph,t as default};
//# sourceMappingURL=index.modern.js.map
