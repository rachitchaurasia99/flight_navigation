{"version":3,"file":"index.module.js","sources":["../src/index.ts"],"sourcesContent":["export type NodeId = string;\nexport type EdgeWeight = number;\nexport type EncodedEdge = string;\n\nexport interface Serialized {\n  nodes: { id: NodeId }[];\n  links: { source: NodeId; target: NodeId; weight: EdgeWeight }[];\n}\n\nexport class CycleError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CycleError.prototype);\n  }\n}\n\nexport function Graph(serialized?: Serialized) {\n  // Returned graph instance\n  const graph = {\n    addNode,\n    removeNode,\n    nodes,\n    adjacent,\n    addEdge,\n    removeEdge,\n    hasEdge,\n    setEdgeWeight,\n    getEdgeWeight,\n    indegree,\n    outdegree,\n    depthFirstSearch,\n    hasCycle,\n    lowestCommonAncestors,\n    topologicalSort,\n    shortestPath,\n    shortestPaths,\n    serialize,\n    deserialize,\n  };\n\n  // The adjacency list of the graph.\n  // Keys are node ids.\n  // Values are adjacent node id arrays.\n  const edges: Record<NodeId, NodeId[]> = {};\n\n  // The weights of edges.\n  // Keys are string encodings of edges.\n  // Values are weights (numbers).\n  const edgeWeights: Record<EncodedEdge, EdgeWeight> = {};\n\n  // If a serialized graph was passed into the constructor, deserialize it.\n  if (serialized) {\n    deserialize(serialized);\n  }\n\n  // Adds a node to the graph.\n  // If node was already added, this function does nothing.\n  // If node was not already added, this function sets up an empty adjacency list.\n  function addNode(node: NodeId) {\n    edges[node] = adjacent(node);\n    return graph;\n  }\n\n  // Removes a node from the graph.\n  // Also removes incoming and outgoing edges.\n  function removeNode(node: NodeId) {\n    // Remove incoming edges.\n    Object.keys(edges).forEach(function (u) {\n      edges[u].forEach(function (v) {\n        if (v === node) {\n          removeEdge(u, v);\n        }\n      });\n    });\n\n    // Remove outgoing edges (and signal that the node no longer exists).\n    delete edges[node];\n\n    return graph;\n  }\n\n  // Gets the list of nodes that have been added to the graph.\n  function nodes(): NodeId[] {\n    // TODO: Better implementation with set data structure\n    const nodeSet: Record<NodeId, boolean> = {};\n\n    Object.keys(edges).forEach(function (u) {\n      nodeSet[u] = true;\n      edges[u].forEach(function (v) {\n        nodeSet[v] = true;\n      });\n    });\n    return Object.keys(nodeSet);\n  }\n\n  // Gets the adjacent node list for the given node.\n  // Returns an empty array for unknown nodes.\n  function adjacent(node: NodeId): NodeId[] {\n    return edges[node] || [];\n  }\n\n  // Computes a string encoding of an edge,\n  // for use as a key in an object.\n  function encodeEdge(u: NodeId, v: NodeId): EncodedEdge {\n    return u + \"|\" + v;\n  }\n\n  // Sets the weight of the given edge.\n  function setEdgeWeight(u: NodeId, v: NodeId, weight: EdgeWeight) {\n    edgeWeights[encodeEdge(u, v)] = weight;\n    return graph;\n  }\n\n  // Gets the weight of the given edge.\n  // Returns 1 if no weight was previously set.\n  function getEdgeWeight(u: NodeId, v: NodeId): EdgeWeight {\n    const weight = edgeWeights[encodeEdge(u, v)];\n    return weight === undefined ? 1 : weight;\n  }\n\n  // Adds an edge from node u to node v.\n  // Implicitly adds the nodes if they were not already added.\n  function addEdge(u: NodeId, v: NodeId, weight?: EdgeWeight) {\n    addNode(u);\n    addNode(v);\n    adjacent(u).push(v);\n\n    if (weight !== undefined) {\n      setEdgeWeight(u, v, weight);\n    }\n\n    return graph;\n  }\n\n  // Removes the edge from node u to node v.\n  // Does not remove the nodes.\n  // Does nothing if the edge does not exist.\n  function removeEdge(u: NodeId, v: NodeId) {\n    if (edges[u]) {\n      edges[u] = adjacent(u).filter(function (_v) {\n        return _v !== v;\n      });\n    }\n    return graph;\n  }\n\n  // Returns true if there is an edge from node u to node v.\n  function hasEdge(u: NodeId, v: NodeId) {\n    return adjacent(u).includes(v);\n  }\n\n  // Computes the indegree for the given node.\n  // Not very efficient, costs O(E) where E = number of edges.\n  function indegree(node: NodeId) {\n    let degree = 0;\n    function check(v: NodeId) {\n      if (v === node) {\n        degree++;\n      }\n    }\n    Object.keys(edges).forEach(function (u) {\n      edges[u].forEach(check);\n    });\n    return degree;\n  }\n\n  // Computes the outdegree for the given node.\n  function outdegree(node: NodeId) {\n    return node in edges ? edges[node].length : 0;\n  }\n\n  // Depth First Search algorithm, inspired by\n  // Cormen et al. \"Introduction to Algorithms\" 3rd Ed. p. 604\n  // The additional option `includeSourceNodes` specifies whether to\n  // include or exclude the source nodes from the result (true by default).\n  // If `sourceNodes` is not specified, all nodes in the graph\n  // are used as source nodes.\n  function depthFirstSearch(\n    sourceNodes?: NodeId[],\n    includeSourceNodes: boolean = true,\n    errorOnCycle: boolean = false,\n  ) {\n    if (!sourceNodes) {\n      sourceNodes = nodes();\n    }\n\n    if (typeof includeSourceNodes !== \"boolean\") {\n      includeSourceNodes = true;\n    }\n\n    const visited: Record<NodeId, boolean> = {};\n    const visiting: Record<NodeId, boolean> = {};\n    const nodeList: NodeId[] = [];\n\n    function DFSVisit(node: NodeId) {\n      if (visiting[node] && errorOnCycle) {\n        throw new CycleError(\"Cycle found\");\n      }\n      if (!visited[node]) {\n        visited[node] = true;\n        visiting[node] = true; // temporary flag while visiting\n        adjacent(node).forEach(DFSVisit);\n        visiting[node] = false;\n        nodeList.push(node);\n      }\n    }\n\n    if (includeSourceNodes) {\n      sourceNodes.forEach(DFSVisit);\n    } else {\n      sourceNodes.forEach(function (node) {\n        visited[node] = true;\n      });\n      sourceNodes.forEach(function (node) {\n        adjacent(node).forEach(DFSVisit);\n      });\n    }\n\n    return nodeList;\n  }\n\n  // Returns true if the graph has one or more cycles and false otherwise\n  function hasCycle(): boolean {\n    try {\n      depthFirstSearch(undefined, true, true);\n      // No error thrown -> no cycles\n      return false;\n    } catch (error) {\n      if (error instanceof CycleError) {\n        return true;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  // Least Common Ancestors\n  // Inspired by https://github.com/relaxedws/lca/blob/master/src/LowestCommonAncestor.php code\n  // but uses depth search instead of breadth. Also uses some optimizations\n  function lowestCommonAncestors(node1: NodeId, node2: NodeId) {\n    const node1Ancestors: NodeId[] = [];\n    const lcas: NodeId[] = [];\n\n    function CA1Visit(visited: Record<NodeId, boolean>, node: NodeId): boolean {\n      if (!visited[node]) {\n        visited[node] = true;\n        node1Ancestors.push(node);\n        if (node == node2) {\n          lcas.push(node);\n          return false; // found - shortcut\n        }\n        return adjacent(node).every((node) => {\n          return CA1Visit(visited, node);\n        });\n      } else {\n        return true;\n      }\n    }\n\n    function CA2Visit(visited: Record<NodeId, boolean>, node: NodeId) {\n      if (!visited[node]) {\n        visited[node] = true;\n        if (node1Ancestors.indexOf(node) >= 0) {\n          lcas.push(node);\n        } else if (lcas.length == 0) {\n          adjacent(node).forEach((node) => {\n            CA2Visit(visited, node);\n          });\n        }\n      }\n    }\n\n    if (CA1Visit({}, node1)) {\n      // No shortcut worked\n      CA2Visit({}, node2);\n    }\n\n    return lcas;\n  }\n\n  // The topological sort algorithm yields a list of visited nodes\n  // such that for each visited edge (u, v), u comes before v in the list.\n  // Amazingly, this comes from just reversing the result from depth first search.\n  // Cormen et al. \"Introduction to Algorithms\" 3rd Ed. p. 613\n  function topologicalSort(\n    sourceNodes?: NodeId[],\n    includeSourceNodes: boolean = true,\n  ) {\n    return depthFirstSearch(sourceNodes, includeSourceNodes, true).reverse();\n  }\n\n  // Dijkstra's Shortest Path Algorithm.\n  // Cormen et al. \"Introduction to Algorithms\" 3rd Ed. p. 658\n  // Variable and function names correspond to names in the book.\n  function shortestPath(source: NodeId, destination: NodeId) {\n    // Upper bounds for shortest path weights from source.\n    const d: Record<NodeId, EdgeWeight> = {};\n\n    // Predecessors.\n    const p: Record<NodeId, NodeId> = {};\n\n    // Poor man's priority queue, keyed on d.\n    let q: Record<NodeId, boolean> = {};\n\n    function initializeSingleSource() {\n      nodes().forEach(function (node) {\n        d[node] = Infinity;\n      });\n      if (d[source] !== Infinity) {\n        throw new Error(\"Source node is not in the graph\");\n      }\n      if (d[destination] !== Infinity) {\n        throw new Error(\"Destination node is not in the graph\");\n      }\n      d[source] = 0;\n    }\n\n    // Adds entries in q for all nodes.\n    function initializePriorityQueue() {\n      nodes().forEach(function (node) {\n        q[node] = true;\n      });\n    }\n\n    // Returns true if q is empty.\n    function priorityQueueEmpty() {\n      return Object.keys(q).length === 0;\n    }\n\n    // Linear search to extract (find and remove) min from q.\n    function extractMin(): NodeId | null {\n      let min = Infinity;\n      let minNode;\n      Object.keys(q).forEach(function (node) {\n        if (d[node] < min) {\n          min = d[node];\n          minNode = node;\n        }\n      });\n      if (minNode === undefined) {\n        // If we reach here, there's a disconnected subgraph, and we're done.\n        q = {};\n        return null;\n      }\n      delete q[minNode];\n      return minNode;\n    }\n\n    function relax(u: NodeId, v: NodeId) {\n      const w = getEdgeWeight(u, v);\n      if (d[v] > d[u] + w) {\n        d[v] = d[u] + w;\n        p[v] = u;\n      }\n    }\n\n    function dijkstra() {\n      initializeSingleSource();\n      initializePriorityQueue();\n      while (!priorityQueueEmpty()) {\n        const u = extractMin();\n        if (u === null) return;\n        adjacent(u).forEach(function (v) {\n          relax(u as string, v);\n        });\n      }\n    }\n\n    // Assembles the shortest path by traversing the\n    // predecessor subgraph from destination to source.\n    function path() {\n      const nodeList: NodeId[] & { weight?: EdgeWeight } = [];\n      let weight = 0;\n      let node = destination;\n      while (p[node]) {\n        nodeList.push(node);\n        weight += getEdgeWeight(p[node], node);\n        node = p[node];\n      }\n      if (node !== source) {\n        throw new Error(\"No path found\");\n      }\n      nodeList.push(node);\n      nodeList.reverse();\n      nodeList.weight = weight;\n      return nodeList;\n    }\n\n    dijkstra();\n\n    return path();\n  }\n\n  function shortestPaths(source: NodeId, destination: NodeId) {\n    let path = shortestPath(source, destination);\n    const paths = [path],\n      removedEdges: { u: NodeId; v: NodeId; weight: EdgeWeight }[] = [],\n      weight = path.weight;\n    while (weight) {\n      const u = path[0];\n      const v = path[1];\n\n      if (hasEdge(u, v)) {\n        removedEdges.push({ u, v, weight: getEdgeWeight(u, v) });\n        removeEdge(u, v);\n      }\n\n      if (hasEdge(v, u)) {\n        removedEdges.push({ u: v, v: u, weight: getEdgeWeight(v, u) });\n        removeEdge(v, u);\n      }\n\n      try {\n        path = shortestPath(source, destination);\n        if (!path.weight || weight < path.weight) break;\n        paths.push(path);\n      } catch (e) {\n        break;\n      }\n    }\n    for (const { u, v, weight } of removedEdges) addEdge(u, v, weight);\n    return paths;\n  }\n\n  // Serializes the graph.\n  function serialize() {\n    const serialized: Serialized = {\n      nodes: nodes().map(function (id) {\n        return { id: id };\n      }),\n      links: [],\n    };\n\n    serialized.nodes.forEach(function (node) {\n      const source = node.id;\n      adjacent(source).forEach(function (target) {\n        serialized.links.push({\n          source: source,\n          target: target,\n          weight: getEdgeWeight(source, target),\n        });\n      });\n    });\n\n    return serialized;\n  }\n\n  // Deserializes the given serialized graph.\n  function deserialize(serialized: Serialized) {\n    serialized.nodes.forEach(function (node) {\n      addNode(node.id);\n    });\n    serialized.links.forEach(function (link) {\n      addEdge(link.source, link.target, link.weight);\n    });\n    return graph;\n  }\n\n  // The returned graph instance.\n  return graph;\n}\n\nexport default Graph;\n"],"names":["CycleError","message","_this","_Error","call","this","Object","setPrototypeOf","_assertThisInitialized","prototype","_wrapNativeSuper","Error","Graph","serialized","graph","addNode","removeNode","node","keys","edges","forEach","u","v","removeEdge","nodes","adjacent","addEdge","hasEdge","setEdgeWeight","getEdgeWeight","indegree","degree","check","outdegree","length","depthFirstSearch","hasCycle","undefined","error","lowestCommonAncestors","node1","node2","node1Ancestors","lcas","visited","push","every","CA1Visit","indexOf","CA2Visit","topologicalSort","sourceNodes","includeSourceNodes","reverse","shortestPath","shortestPaths","source","destination","path","removedEdges","weight","paths","e","_i","_removedEdges","_removedEdges$_i","serialize","map","id","links","target","deserialize","edgeWeights","nodeSet","encodeEdge","filter","_v","includes","errorOnCycle","visiting","nodeList","DFSVisit","d","p","Infinity","initializeSingleSource","q","_loop","minNode","min","w","relax","dijkstra","link"],"mappings":"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"}